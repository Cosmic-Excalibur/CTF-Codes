

# This file was *autogenerated* from the file ./test_4p_1.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_27 = Integer(27); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1728 = Integer(1728); _sage_const_4 = Integer(4); _sage_const_811451435 = Integer(811451435); _sage_const_512 = Integer(512); _sage_const_2147483647 = Integer(2147483647)
from Crypto.Util.number import *
import sys

def polynomial_egcd(f, g):
    old_r, r = f, g
    old_s, s = _sage_const_1 , _sage_const_0 
    old_t, t = _sage_const_0 , _sage_const_1 

    while r != _sage_const_0 :
        try:
            q = old_r // r
            old_r, r = r, old_r - q * r
            old_s, s = s, old_s - q * s
            old_t, t = t, old_t - q * t
        except:
            raise ValueError("No inverse for r in Q.", r)

    return old_r, old_s, old_t

def polynomial_inv_mod(f, g):
    g, s, _ = polynomial_egcd(f, g)

    if g.degree() > _sage_const_1 :
        raise ValueError("No polynomial inverse exists.")

    return s * g.lc()**-_sage_const_1 

def super_xgcd(f, g, N):
    toswap = False
    if f.degree() < g.degree():
        toswap = True
        f, g = g, f
    r_i = f
    r_i_plus = g
    r_i_plus_plus = f
    s_i, s_i_plus = _sage_const_1 , _sage_const_0 
    t_i, t_i_plus = _sage_const_0 , _sage_const_1 
    while (True):
        lc = r_i.lc().lift()
        lc *= r_i_plus.lc().lift()
        lc *= r_i_plus_plus.lc().lift()
        divisor = gcd(lc, N)
        if divisor > _sage_const_1 :
            return divisor, None, None
        q = r_i // r_i_plus
        s_i_plus_plus = s_i - q * s_i_plus
        t_i_plus_plus = t_i - q * t_i_plus
        r_i_plus_plus = r_i - q * r_i_plus
        if r_i_plus.degree() <= r_i_plus_plus.degree() or r_i_plus_plus.degree() == -_sage_const_1 :
            if toswap == True:
                return r_i_plus, t_i_plus, s_i_plus
            else:
                return r_i_plus, s_i_plus, t_i_plus
        r_i, r_i_plus = r_i_plus, r_i_plus_plus
        s_i, s_i_plus = s_i_plus, s_i_plus_plus
        t_i, t_i_plus = t_i_plus, t_i_plus_plus

def solution(D, N):
    N = int(N)
    Zn = Zmod(N)
    while _sage_const_1 :
        P = Zn['RT']; (RT,) = P._first_ngens(1)
        #W = P([1, 2, -1, -1, 1, -1, -1, 1])
        #T = P([-1, 237, -235, 47, -76, 248, -159, 75, -9, 1])
        T = P(load("ramanujan_811451435.sobj"))
        h = T.degree()
        r = randrange(_sage_const_1 , N)
        #j = (X**24 - 16)**3 * polynomial_inv_mod(X**24, W)
        j = (RT**_sage_const_6 -_sage_const_27 *polynomial_inv_mod(RT**_sage_const_6 ,T)-_sage_const_6 )**_sage_const_3 
        A = _sage_const_3 *j*r**_sage_const_2  * polynomial_inv_mod((_sage_const_1728 -j), T)
        B = _sage_const_2 *j*r**_sage_const_3  * polynomial_inv_mod((_sage_const_1728 -j), T)
        R = P.quo(T, names=('j',)); (j,) = R._first_ngens(1)
        E = EllipticCurve(R, [A, B])
        #d = E.division_polynomial(N, x=X, two_torsion_multiplicity=0)
        d = E.division_polynomial(N, x=RT, two_torsion_multiplicity=_sage_const_0 )
        g = super_xgcd(d.lift(), T, N)[_sage_const_0 ]
        if g not in [_sage_const_0 , _sage_const_1 , N]:
            return int(g)

def gen_4p_1_prime(D, pbits):
    while _sage_const_1 :
        V = getRandomNBitInteger((pbits - int(D).bit_length() + _sage_const_2 ) // _sage_const_2 )
        p = (D * V ** _sage_const_2  + _sage_const_1 ) / _sage_const_4 
        if p.denom() == _sage_const_1  and isPrime(int(p)):
            return p

def main(D = _sage_const_811451435 , pbits = _sage_const_512 ):
    sys.setrecursionlimit(_sage_const_2147483647 )
    print("[\033[34m\033[1m*\033[0m] Generating random prime numbers...")
    p = gen_4p_1_prime(D, pbits)
    q = getPrime(pbits)
    n = p * q
    print(f"[\033[34m\033[1m*\033[0m] Expectations:\nD = {D}\nn = {n}\np = {p}\nq = {q}")
    p_ = solution(D, n)
    if all([n % p_ == _sage_const_0 , p_ not in [_sage_const_1 , n]]):
        q_ = n // p_
        print(f'\n[\033[32m\033[1m+\033[0m] Backdoor Factors Found:\n{n} == {p_} * {q_}')
    else:
        print(f'\n[\033[31m\033[1m-\033[0m] Failed :(')

if "__main__" == __name__:
    main()

